@page "/Add"
<h3>Add</h3>
@using Sklad.Components.Models
@using Sklad.Components.Services
@using System.Threading

@using FluentValidation


<MudCard>


    <MudForm Model="@model" @ref="@form" Validation="@(toolValidator.ValidateValue)" ValidationDelay="0">
        <MudCardContent>

            <MudTextField @bind-Value="model.Name"
                          For="@(() => model.Name)"
                          Immediate="true"
                          Label="Name"/>

            <MudNumericField @bind-Value="model.Quantity"
                             Immediate="true"
                             Label="Quantity"/>

            <MudTextField @bind-Value="model.Location"
                          For="@(() => model.Location)"
                          Immediate="true"
                          Label="Location"/>

            <MudRadioGroup T="string" @bind-Value="model.Location" Label="Location">
                @foreach (var location in Locations.Where(l => !string.IsNullOrWhiteSpace(l)))
                {
                    <MudRadio Value="@location">@location</MudRadio>
                }
            </MudRadioGroup>
            
            


            <MudTextField @bind-Value="model.Category"
                          For="@(() => model.Category)"
                          Immediate="true"
                          Label="Category"/>

            <MudRadioGroup T="string" @bind-Value="model.Category" Label="Category">
                @foreach (var category in Categories.Where(l => !string.IsNullOrWhiteSpace(l)))
                {
                    <MudRadio Value="@category">@category</MudRadio>
                }
            </MudRadioGroup>

            <MudTextField @bind-Value="model.Description"
                          Immediate="true"
                          Label="Description"/>

            <MudTextField @bind-Value="model.Condition"
                          For="@(() => model.Condition)"
                          Immediate="true"
                          Label="Condition"/>

            <MudRadioGroup T="string" @bind-Value="model.Condition" Label="Condition">
                @foreach (var condition in Conditions.Where(l => !string.IsNullOrWhiteSpace(l)))
                {
                    <MudRadio Value="@condition">@condition</MudRadio>
                }
            </MudRadioGroup>

            
            <MudSwitch T="bool" @bind-Checked="model.Borrowed" Label="Borrowed" Color="Color.Primary" />


            <MudTextField @bind-Value="model.Tags"
                          Immediate="true"
                          Label="Tags"/>

            <MudTextField @bind-Value="model.Borrower"
                          Immediate="true"
                          Label="Borrower"/>

            <MudDatePicker @bind-Date="model.ReturnDate" Label="Return Date"/>

            <MudDatePicker @bind-Date="model.DateModified" Label="Date Modified"/>

            <MudTextField @bind-Value="model.ImagePath"
                          Immediate="true"
                          Label="Image Path"/>


        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto" OnClick="@(async () => await Submit())">
                Save
            </MudButton>
        </MudCardActions>
    </MudForm>
</MudCard>


@code {
    [Inject] ISnackbar Snackbar { get; set; }
    [Inject] ToolService ToolService { get; set; }

    MudForm form;

    ToolModelFluentValidator toolValidator = new();

    ToolModel model = new ToolModel
    {
        DateAdded = DateTime.UtcNow // Używamy UTC
    };

    private IEnumerable<string> Locations = Enumerable.Empty<string>();
    private IEnumerable<string> Categories = Enumerable.Empty<string>();
    private IEnumerable<string> Conditions = Enumerable.Empty<string>();

    protected override async Task OnInitializedAsync()
    {
        var locations = await ToolService.GetLocationsAsync();
        if (locations != null && locations.Any())
        {
            Locations = locations;
        }

        var categories = await ToolService.GetCategoriesAsync();
        if (categories != null && categories.Any())
        {
            Categories = categories;
        }

        var conditions = await ToolService.GetConditionsAsync();
        if (conditions != null && conditions.Any())
        {
            Conditions = conditions;
        }
    }


    public class ToolModel
    {
        public string? Name { get; set; }
        public string? Description { get; set; }
        public string? Location { get; set; }
        public bool Borrowed { get; set; }
        public DateTime DateAdded { get; set; }
        public DateTime? DateModified { get; set; }
        public string? Category { get; set; }
        public string? Condition { get; set; }
        public string? Borrower { get; set; }
        public DateTime? ReturnDate { get; set; }
        public string? Tags { get; set; }
        public string? ImagePath { get; set; }
        public int Quantity { get; set; }
    }

    private async Task Submit()
    {
        await form.Validate();

        if (form.IsValid)
        {
            // Map the form model to the database entity
            var tool = new Tool
            {
                Name = model.Name,
                Location = model.Location,
                Description = model.Description,
                Borrowed = model.Borrowed,
                DateAdded = model.DateAdded.ToUniversalTime(), // Jeśli `DateAdded` jest zawsze ustawiony
                DateModified = model.DateModified?.ToUniversalTime(), // Obsługuje null
                Category = model.Category,
                Condition = model.Condition,
                Borrower = model.Borrower,
                ReturnDate = model.ReturnDate?.ToUniversalTime(), // Obsługuje null
                Tags = model.Tags,
                ImagePath = model.ImagePath,
                Quantity = model.Quantity
            };


            // Save to the database using the service
            await ToolService.AddToolAsync(tool);
            //avigationManager.NavigateTo("/Warehouse");
            Snackbar.Add("Tool saved successfully!", MudBlazor.Severity.Success);
        }
    }


    public class ToolModelFluentValidator : AbstractValidator<ToolModel>
    {
        public ToolModelFluentValidator()
        {
            RuleFor(x => x.Name)
                .NotEmpty()
                .Length(1, 200);
            RuleFor(x => x.Location)
                .NotEmpty()
                .Length(1, 200);
            RuleFor(x => x.Description)
                .NotEmpty()
                .Length(1, 200);

            RuleFor(x => x.Quantity)
                .NotEmpty()
                .GreaterThan(0);

            RuleFor(x => x.Category)
                .NotEmpty()
                .Length(1, 100);

            RuleFor(x => x.Condition)
                .NotEmpty()
                .Length(1, 100);

            RuleFor(x => x.Borrower)
                .Length(0, 100);

            RuleFor(x => x.Tags)
                .Length(0, 100);

            RuleFor(x => x.ImagePath)
                .Length(0, 200);
        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<ToolModel>.CreateWithOptions((ToolModel)model, x => x.IncludeProperties(propertyName)));
            if (result.IsValid)
                return Array.Empty<string>();
            return result.Errors.Select(e => e.ErrorMessage);
        };
    }
    
    
}
