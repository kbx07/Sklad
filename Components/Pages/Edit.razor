@page "/Edit"

@using FluentValidation
@using Sklad.Components.Models
@using Sklad.Components.Services
@page "/Edit/{ToolId:int}"
<h3>Edit</h3>

<MudCard>
    
    <MudForm Model="@_model" @ref="@_form" Validation="@(_toolValidator.ValidateValue)" ValidationDelay="0">
        
        <MudCardContent>

            <MudTextField @bind-Value="_model.Name"
                          Immediate="true"
                          Label="Name"
                          Style="width: 60%;"
                          For="@(() => _model.Name)"/>

            <MudDivider/>

            <MudNumericField RowGap="50px" @bind-Value="_model.Quantity"
                             Immediate="true"
                             Label="Quantity"
                             Style="width: 60%;"
                             For="@(() => _model.Quantity)"/>

            <MudGrid RowSpacing="2" ColumnSpacing="5">
                <MudItem xs="90">
                    <MudTextField @bind-Value="_model.Location"
                                  Immediate="true"
                                  Label="Enter a new location"
                                  For="@(() => _model.Location)"/>
                </MudItem>

                <MudItem xs="250" Style="width: 15%;">
                    <MudSelect T="string" @bind-Value="_model.Location" Label="Choose saved location" Style="width: 100%;">
                        @foreach (var lok in _locations.Where(l => !string.IsNullOrWhiteSpace(l)))
                        {
                            <MudSelectItem Value="@lok">@lok</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            </MudGrid>


            <MudGrid Rowspacing="2" ColumnSpacing="5">
                <MudItem xs="90">
                    <MudTextField @bind-Value="_model.Category"
                                  Immediate="true"
                                  Label="Enter a new category"
                                  For="@(() => _model.Category)"/>
                </MudItem>
                <MudItem xs="250" Style="width: 15%;">
                    <MudSelect T="string"
                               @bind-Value="_model.Category"
                               Label="Choose saved category">
                        @foreach (var cat in _categories.Where(l => !string.IsNullOrWhiteSpace(l)))
                        {
                            <MudSelectItem Value="@cat">@cat</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            </MudGrid>

            <MudTextField @bind-Value="_model.Description"
                          Immediate="true"
                          Label="Description"
                          Style="width: 60%;"
                         />


            <MudGrid RowSpacer="2" ColumnSpacer="2">
                <MudItem xs="90">
                    <MudTextField @bind-Value="_model.Condition"
                                  Immediate="true"
                                  Label="Condition"
                                  For="@(() => _model.Condition)"/>
                </MudItem>
                <MudItem xs="250" Style="width: 15%">
                    <MudSelect T="string" @bind-Value="_model.Condition" Label="Condition">
                        @foreach (var condition in _conditions.Where(l => !string.IsNullOrWhiteSpace(l)))
                        {
                            <MudSelectItem Value="@condition">@condition</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            </MudGrid>

            <MudSwitch T="bool"
                       @bind-Checked="_model.Borrowed"
                       Label="Borrowed"
                       Color="Color.Primary"
                       Style="width: 60%;"/>

            <MudTextField @bind-Value="_model.Tags"
                          Immediate="true"
                          Label="Tags"
                          Style="width: 60%;"
                          For="@(() => _model.Tags)"/>

            <MudTextField @bind-Value="_model.Borrower"
                          Immediate="true"
                          Label="Borrower"
                          Style="width: 60%;"
                          For="@(() => _model.Borrower)"/>

            <MudDatePicker @bind-Date="_model.ReturnDate"
                           Label="Return Date"
                           Style="width: 60%;"/>

            <MudDatePicker @bind-Date="_model.DateModified"
                           Label="Date Modified"
                           Style="width: 60%;"/>
            
            <MudTextField @bind-Value="_model.ImagePath"
                          Immediate="true"
                          Label="Image Path"
                          Style="width: 60%;"
                          For="@(() => _model.ImagePath)"/>
            
        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto" OnClick="@(async () => await Submit())">
                Save
            </MudButton>
        </MudCardActions>
    </MudForm>
</MudCard>



@* ReSharper disable once UnassignedField.Compiler *@
@code {
    [Inject] ISnackbar? Snackbar { get; set; }
    [Inject] ToolService? ToolService { get; set; }
    [Inject] NavigationManager? NavigationManager { get; set; }

    private MudForm? _form;
    private ToolModelFluentValidator _toolValidator = new();
    private ToolModel _model = new ToolModel { DateAdded = DateTime.Now };

    [Parameter] public int? ToolId { get; set; }
    private IEnumerable<string?> _locations = new List<string>();
    private IEnumerable<string?> _categories = new List<string>();
    private IEnumerable<string?> _conditions = new List<string>();
    private string? _newLocation; 

    private readonly bool _isAddingNewLocation = false;

    protected override async Task OnInitializedAsync()
    {
        if (ToolService != null)
        {
            _locations = await ToolService.GetLocationsAsync();
            _categories = await ToolService.GetCategoriesAsync();
            _conditions = await ToolService.GetConditionsAsync();

            if (ToolId.HasValue)
            {
                var tool = await ToolService.GetToolByIdAsync(ToolId.Value);
                if (tool != null)
                {
                    _model = new ToolModel
                    {
                        Name = tool.Name,
                        Location = tool.Location,
                        Description = tool.Description,
                        Borrowed = tool.Borrowed,
                        DateAdded = tool.DateAdded,
                        DateModified = tool.DateModified,
                        Category = tool.Category,
                        Condition = tool.Condition,
                        Borrower = tool.Borrower,
                        ReturnDate = tool.ReturnDate,
                        Tags = tool.Tags,
                        ImagePath = tool.ImagePath,
                        Quantity = tool.Quantity
                    };
                }
            }
        }
    }
    public class ToolModel
    {
        public string? Name { get; set; }
        public string? Description { get; set; }
        public string? Location { get; set; }
        public bool Borrowed { get; set; }
        public DateTime DateAdded { get; set; }
        public DateTime? DateModified { get; set; }
        public string? Category { get; set; }
        public string? Condition { get; set; }
        public string? Borrower { get; set; }
        public DateTime? ReturnDate { get; set; }
        public string? Tags { get; set; }
        public string? ImagePath { get; set; }
        public int Quantity { get; set; }
    }
    public class ToolModelFluentValidator : AbstractValidator<ToolModel>
    {
        public ToolModelFluentValidator()
        {
            RuleFor(x => x.Name)
                .NotEmpty().WithMessage("Name cannot be empty!")
                .Length(1, 200);
            RuleFor(x => x.Location)
                .NotEmpty().WithMessage("Location cannot be empty!")
                .Length(1, 200);
            RuleFor(x => x.Description)
                .Length(1, 200);

            RuleFor(x => x.Quantity)
                .NotEmpty().WithMessage("Quantity cannot be empty!")
                .GreaterThan(0);

            RuleFor(x => x.Category)
                .NotEmpty().WithMessage("Category cannot be empty!")
                .Length(1, 100);

            RuleFor(x => x.Condition)
                //.NotEmpty()
                .Length(1, 100);

            RuleFor(x => x.Borrower)
                .Length(0, 100);
                
            RuleFor(x => x.Tags)
                .Length(0, 100);

            RuleFor(x => x.ImagePath)
                .Length(0, 200);
        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<ToolModel>.CreateWithOptions((ToolModel)model, x => x.IncludeProperties(propertyName)));
            if (result.IsValid)
                return Array.Empty<string>();
            return result.Errors.Select(e => e.ErrorMessage);
        };
    }

    private async Task Submit()
{
    await _form.Validate();

    if (_form.IsValid)
    {
        if (_isAddingNewLocation && !string.IsNullOrWhiteSpace(_newLocation))
        {
            _model.Location = _newLocation;
            await ToolService.AddLocationAsync(_newLocation);
            _locations = await ToolService.GetLocationsAsync();
        }
        
        if (ToolId.HasValue)
        {
            var existingTool = await ToolService.GetToolByIdAsync(ToolId.Value);
            if (existingTool == null)
            {
                Snackbar.Add("Tool not found for editing.", MudBlazor.Severity.Error);
                return;
            }
            
            existingTool.Name = _model.Name;
            existingTool.Location = _model.Location;
            existingTool.Description = _model.Description;
            existingTool.Borrowed = _model.Borrowed;
            existingTool.DateAdded = _model.DateAdded;
            existingTool.DateModified = DateTime.Now;
            existingTool.Category = _model.Category;
            existingTool.Condition = _model.Condition;
            existingTool.Borrower = _model.Borrower;
            existingTool.ReturnDate = _model.ReturnDate;
            existingTool.Tags = _model.Tags;
            existingTool.ImagePath = _model.ImagePath;
            existingTool.Quantity = _model.Quantity;
            
            await ToolService.UpdateToolAsync(existingTool, existingTool.Id);
        }
        else
        {
            var newTool = new Tool
            {
                Name = _model.Name,
                Location = _model.Location,
                Description = _model.Description,
                Borrowed = _model.Borrowed,
                DateAdded = DateTime.Now,
                DateModified = DateTime.Now,
                Category = _model.Category,
                Condition = _model.Condition,
                Borrower = _model.Borrower,
                ReturnDate = _model.ReturnDate,
                Tags = _model.Tags,
                ImagePath = _model.ImagePath,
                Quantity = _model.Quantity
            };

            await ToolService.AddToolAsync(newTool);
        }

        Snackbar?.Add("Tool saved successfully!", MudBlazor.Severity.Success);
        NavigationManager?.NavigateTo("/Warehouse");
    }
}
}